class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        tempDict = {}
        maxLen = 0
        pointer = 0
        for index, value in enumerate(s):
            if value in tempDict:
                pointer = max(tempDict[value]+1, pointer)
            maxLen = max(index-pointer+1, maxLen)
            tempDict[value] = index
        return maxLen


class Solution:
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        j = 0
        dic = {}
        res = 0
        for i, num in enumerate(s):
            if num in dic:
                j = max(j, dic[num] + 1)          
            res = max(res, i - j + 1)         
            dic[num] = i
        return res



class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> map_char;
	    int max_Len = 0;
	    int i = 0, j = 0;
	    for(;i<s.length();i++)
	    {
		    if (map_char[s[i]])		// 如果已经出现过该字符
		    {
			    while (j+1 < i && s[j] != s[i])     // 将后面的索引向前移动
				    map_char[s[j++]]--;     // 相应字符从字典中去除
			    j++;    //将后面的索引移到重复的字符的后面一位
		    }
		    else
			    map_char[s[i]]++;   // 对字典相应位置加1
		    max_Len = max(max_Len, i-j+1);
	    }
	    return max_Len;
    }
};


Sort By
